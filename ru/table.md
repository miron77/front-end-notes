# Оригинальная HTML4 таблица

Когда появилась необходимость в HTML разметке показывать таблицы - изобрели тег `<table>`.
Что же даёт нам [таблица](http://caniuse.com/#feat=css-table) в браузере?
Вот несколько основных "фич":

1. Если мы не указали ширину таблицы/столбцов, то ширина таблицы [подстраивается и растягивается](https://codepen.io/volodalexey/pen/bRqEEG), чтобы вместить содержимое любого из столбцов.

2. Если мы указали ширину таблицы, и если указанная ширина больше чем содержимое (см. пункт 1) тогда таблица растягивается.
Самое интересное [как растягивается таблица](https://codepen.io/volodalexey/pen/weJGWd).
В данном случае она вычисляет процентное отношение каждого столбца (см. пункт 1) и расстягивает каждый столбец соответственно процентному соотношению.
В пункте 1 ширина всей таблицы (примерно): `387px`, колонки `Company` : `206px`, колонки `Contact` : `115px`.
Итого в процентах `Company` : `206px/387px * 100% = 53%`, `Contact` : `115px/387px * 100% = 30%`.
Теперь когда таблица растянулась ширина всей таблицы (примерно на моем экране): `1836px`, колонки `Company` : `982px`, колонки `Contact` : `551px`.
В процентах `Company` : `982px/1836px * 100% = 53%`, `Contact` : `551px/1836px * 100% = 30%`.

3. Если мы указали ширину таблицы и если указанная ширина меньше чем содержимое (см. пункт 1) тогда таблица сужается.
Но сужается [до минимально возможной ширины каждого столбца](https://codepen.io/volodalexey/pen/qjrZNz).
Можно "дожать" [таблицу](https://codepen.io/volodalexey/pen/KqWzgQ) указав ей CSS свойство `table-layout: fixed`. [Описание](https://www.w3.org/TR/html4/appendix/notes.html#h-B.5.2.1) к свойству.
Так мы ломаем автовычисление и теперь таблица слушается заданных ширин для каждого столбца (или всей таблицы), но зато таблица точно вписывается в указанную ширину.
Если мы не указали ширину столбцов, тогда при ["сломанной" таблице](https://codepen.io/volodalexey/pen/QgpNOm), `ширина каждого столбца = вся ширина / количество столбцов`.

4. Схлопывание (наложение) границ ячеек/столбцов `border-collapse: collapse`, если мы указали границы для ячеек.
Т.е. в [местах соприкосновения ячеек](https://codepen.io/volodalexey/pen/MopJyM), не будет двойных граничных линий.

5. Группировка шапки.

## Использование оригинальной таблицы

Во всех вышеприведенный примерах в разметке таблицы я использовал сокращенную разметку:
```html
<table>
  <tr>
    <th>Header 1</th>
    <th>Header 2</th>
  </tr>
  <tr>
    <td>1.1</td>
    <td>1.2</td>
  </tr>
  <tr>
    <td>2.1</td>
    <td>2.2</td>
  </tr>
</table>
```
Однако можно использовать "каноничную" разметку:
```html
<table>
  <thead>
    <tr>
      <th>Header 1</th>
      <th>Header 2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1.1</td>
      <td>1.2</td>
    </tr>
    <tr>
      <td>2.1</td>
      <td>2.2</td>
    </tr>
  </tbody>
</table>
```
Если нам надо таблицу без шапки, но в то же время нам надо контроллировать ширину столбцов:
```html
<table>
  <tbody>
    <colgroup>
      <col width="100px"></col>
      <col width="150px"></col>
    </colgroup>
    <tr>
      <td>1.1</td>
      <td>1.2</td>
    </tr>
    <tr>
      <td>2.1</td>
      <td>2.2</td>
    </tr>
  </tbody>
</table>
```

Чаще всего нам в разметке необходимо получить следующее. У нас есть некий контейнер с заданной шириной или с заданной максимальной шириной.
Внутри него мы хотим показывать таблицу, если ширина таблицы больше чем контейнер, тогда надо показывать скролл для контейнера.
Если ширина таблицы меньше чем контейнер, тогда надо расширять таблицу до ширины контейнера. 
Но ни в коем случае мы не хотим, чтобы таблица сделала наш контейнер шире чем мы задали.
По этой [ссылке](https://codepen.io/volodalexey/pen/NgpNzY) можно уведеть контейнер с таблицей в действии.
Если мы будем сужать контейнер, то в тот момент, когда таблица уже больше не сможет сужаться - появиться скролл.

## Подстройка таблицы

### Задание ширины таблицы и столбцов

Первая дилемма с которой сталкиваются фронт-энд разработчики - это задавать или не задавать ширину столбцов.
Если не задавать, тогда ширина каждого столбца будет вычисляться в зависимости от содержимого (см. пункт 2 и 3).
Исходя из логики, можно понять, что в этом случае браузеру нужно два прохода.
На первом он просто отображает все в таблице, подсчитывает ширину столбцов (мин, макс). 
На втором подстраивает ширину столбцов в зависимости от ширины таблицы.
Со временем вам скажут что таблица выглядит некрасиво, т.к. один из столбцов слишком широкий и `"вот в этом столбце нам надо показать больше текста чем в этом, а у нас наоборот..."`.
И самая распространенная "фича":

6. это сокращение текста с помощью `...`. Т.е. если текст в ячейке вылазит за ширину колонки, то его надо сокращать и в конце добавлять `...`.
Первое разочарование, что если не задавать ширину столбцов, то сокращение не работает.
В этом есть своя логика, т.к. на первом проходе браузер высчитывает мин/макс ширину колонки без сокращения, а тут мы пытаемся сократить текст.
Сокращение реализуется просто, надо указать CSS свойства для ячейки:
```css
td {
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
}
```
И соответственно задать ширину колонки. По этой [ссылке](https://codepen.io/volodalexey/pen/gRmLzW) можно увидеть, что все настроено, но сокращение не работает.
В спецификации есть [заметка](https://www.w3.org/TR/html4/struct/tables.html#column-width), немного объясняющая, почему сокращение не работает: `If column widths prove to be too narrow for the contents of a particular table cell, user agents may choose to reflow the table`.
Опять же можно сужать до определенного предела. Но если применить свойство `table-layout: fixed` то таблица [начнёт слушаться](https://codepen.io/volodalexey/pen/eRWNOV) и сокращение заработает.
Но автоподстройка ширины столбцов уже не работает.

### Задание прокрутки таблицы

Вышеприведенный пример будет работать со скроллом и пользоваться этим можно, однако возникает следующее требование `"здесь нам надо сделать, чтобы шапка таблицы оставась на месте, а тело прокручивалось"`.
Вторая дилемма с которой сталкиваются фронт-энд разработчики:

7. задание прокрутки/скролла в таблице. 
В спецификации таблицы есть [прямое указание](https://www.w3.org/TR/html4/struct/tables.html), что тело таблицы может быть с шапкой и подвалом. Т.е. шапка и подвал всегда видимы.
`User agents may exploit the head/body/foot division to support scrolling of body sections independently of the head and foot sections. When long tables are printed, the head and foot information may be repeated on each page that contains table data`
А есть и указание о том, что тело таблицы можно скроллить, а шапка и подвал будут оставаться на месте:
`Table rows may be grouped into a table head, table foot, and one or more table body sections, using the THEAD, TFOOT and TBODY elements, respectively. This division enables user agents to support scrolling of table bodies independently of the table head and foot`
А по факту браузеры этого не делают и скролл для таблицы надо придумывать вручную.
Есть много способов это сделать, но все они сводяться к тому, что:

8. мы не создаем дополнительную разметку и пытаемся прикрутить скролл к тому что есть

9. мы создаеём дополнительную разметку и тогда при прокрутке оригинала мы синхронизируем дополнительную разметку

Следуя пункту 8 можно задать ограниченную высоту телу таблицы. Предполагая высоту родительского контейнера [попробовать можно](https://codepen.io/volodalexey/pen/dRWoQY).
В результате мы ломаем табличное отображение тела таблицы `display: block`, а также нам необходимо синхронизировать прокрутку шапки с телом таблицы.
А вот следуя пункту 9 - это то где все [предлагают](https://stackoverflow.com/questions/673153/html-table-with-fixed-headers) решения.

# Примеры составных таблиц

Если нам необходима прокрутка тела таблицы, то без составных разметок не обойтись.
Все примеры составных таблиц (см. пункт 9) используют свои пользовательские разметки.
Одна из самых известных таблиц [Data Tables](https://datatables.net/examples/basic_init/scroll_xy.html) использует следующую разметку:
```html
<div class="dataTables_scroll">
  <div class="dataTables_scrollHead">
    <div class="dataTables_scrollHeadInner">
      <table class="display nowrap dataTable no-footer">
        <thead>
          <tr role="row">
            <th class="sorting_asc"></th>
            <th class="sorting"></th>
            <th class="sorting"></th>
          </tr>
        </thead>
      </table>
    </div>
  </div>
  <div class="dataTables_scrollBody">
    <table id="example" class="display nowrap dataTable no-footer">
      <thead>
        <tr role="row">
          <th class="sorting">
            <div class="dataTables_sizing"></div>
          </th>
          <th class="sorting">
            <div class="dataTables_sizing"></div>
          </th>
          <th class="sorting">
            <div class="dataTables_sizing"></div>
          </th>
        </tr>
      </thead>
      <tbody>
        <tr role="row" class="odd">
          <td class="sorting_1"></td>
          <td></td>
          <td></td>
        </tr>
      </tbody>
    </table>
  </div>
</div>
```
Я намеренно сокращаю разметку, чтобы можно было составить общую картину, как разметка выглядит внутри.
Мы видим две таблицы, хотя для пользователя это видится как одна.
Следующий пример [React Bootstrap Table](http://allenfang.github.io/react-bootstrap-table/example.html#basic) если посмотреть в разметку использует две таблицы:
```html
<div class="react-bs-table-container">
  <div class="react-bs-table">
    <div class="react-bs-container-header table-header-wrapper">
      <table class="table table-hover table-bordered">
        <colgroup><col class=""><col class=""><col class=""></colgroup>
        <thead>
          <tr>
            <th></th>
            <th></th>
            <th></th>
          </tr>
        </thead>
      </table>
    </div>
    <div class="react-bs-container-body">
      <table class="table table-bordered">
        <colgroup><col class=""><col class=""><col class=""></colgroup>
        <tbody>
          <tr class="">
            <td></td>
            <td></td>
            <td></td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>
</div>
```
Верхняя таблица отображает заголовок, нижняя - тело. Хотя для пользователя кажется как будто бы это одна таблица.
Опять же пример использует синхронизацию прокрутки, если прокрутить тело таблицы, то произойдет синхронизация заголовка.
А как же получается, что тело таблицы (одна таблица) подстраивается под ширину контейнера, а шапка (другая таблица) подстраивается тоже?
Тут кто как умеет так и синхронизирует, к примеру вот [кусок кода](https://github.com/AllenFang/react-bootstrap-table/blob/a1cd5af3db102214d5e5ed3d959abcbb9489c7b3/src/BootstrapTable.js#L1300) из вышеприведенной библиотеки:
```jsx harmony
componentDidUpdate() {
  ...
  this._adjustHeaderWidth();
  ...
}

_adjustHeaderWidth() {
    ...
    // берем ширину столбцов из тела таблицы если есть хоть один ряд, или берем ширину <col> из тела таблицы
    // и присваиваем шапке полученные размеры
  }
```
Получается вполне логичный вопрос, а зачем тогда вообще использовать тег `<table>`, если собственно из таблицы используется только автоподстройка ширины таблицы?
И тут мы окажемся не первыми и некоторые вообще не используют табличную разметку.
Например [Fixed Data Table](https://facebook.github.io/fixed-data-table/example-object-data.html) или [React Table](https://react-table.js.org/#/story/simple-table).
Разметка в вышеприведенных примерах примерно такая:
```html
<div class="table">
  <div class="header">
    <div class="row">
      <div class="cell"></div>
      <div class="cell"></div>
    </div>
  </div>
  <div class="body">
    <div class="row">
      <div class="cell"></div>
      <div class="cell"></div>        
    </div>
  </div>
</div>
```
Отсюда название `fixed table`, т.е. для такой разметки мы должны заранее указать ширину всех столбцов (ширину таблицы, высоту строки).
Хотя если мы хотим сокращение текста (см. пункт 6), нам все равно надо задавать ширину столбцов, даже в обычной таблице.
А как же сделать автоподстройку ширины колонки в пользовательской таблице спросите вы?
Опять же способы есть разные, наиболее интересный использует дополнительный проход браузера.
Например в этой таблице [ag Grid](https://www.ag-grid.com/example.php) можно автоматически рассчитать подходящую ширину столбца.
В [коде видно](https://github.com/ceolter/ag-grid/blob/bbf11d41d23fffa77dd4d0cd01d72facc77398eb/src/ts/rendering/autoWidthCalculator.ts#L31):
```typescript
    public getPreferredWidthForColumn(column: Column): number {
        // создать <span style="position: fixed;">
        // добавить в него все ячейки столбца
        // вычислить ширину span (вычисляет браузер)
        // удаляем <span style="position: fixed;">
    }
```
Следующая таблица [Reactabular](https://reactabular.js.org/#/easy) использует интересный подход в синхронизации.
Автор пошел дальше и сделал прокручиваемыми не только тело, но и шапку таблицы, в браузерах которые показывают ползунок скролла - выглядит ужасно, зато в `touch` браузерах очень классно и функционально.
Если мы скроллим тело таблицы, то происходит синхронизация шапки, а если мы скроллим шапку, то происходит синхронизация тела.

# Реализация собственной таблицы

Получается, что составная таблица требует дополнительной синхронизации между частями, чтобы для пользователя все вместе казалось как одна таблица.
Все составные таблицы (и моя будущая тоже) страдают одним недостающим фактором, у них нет стандарта (и это логично, т.к. отказались от HTML4 таблицы), как их кастомизировать. 
Когда ты начинаешь учить одну таблицу, потом начинаешь тратить время на её кастомизацию.
Затем для другого проекта учишь другую таблицу (например при переходе с Angular1 на React, или с jQuery на Vue) и кастомизация совсем другая.
Логичный вопрос, а стоит ли потраченное время того? Стоит ли учить снова и снова таблицу? 
Может легче усвоить для себя базовые моменты составной таблицы и тогда вы сможете делать свою таблицу на любом фреймворке (Angular/React/Vue/будущее...)?

К премеру я покажу как сделать свою составную таблицу на React (остались наработки с прошлого проекта, но есть наработки и на VanillaJS).

## Разметка 